"""Grid trading bot strategy.

A grid strategy places buy and sell orders at predefined price levels
within a range. When a buy order fills, a sell order is placed one grid
level above. When a sell order fills, a buy order is placed one grid
level below. This captures profit from price oscillations within the range.

Supports both arithmetic (equal price spacing) and geometric (equal
percentage spacing) grid types.
"""

from dataclasses import dataclass, field
from enum import Enum


class GridType(str, Enum):
    """Type of grid spacing."""

    ARITHMETIC = "arithmetic"
    GEOMETRIC = "geometric"


class LevelStatus(str, Enum):
    """Status of a grid level."""

    EMPTY = "empty"
    PENDING_BUY = "pending_buy"
    PENDING_SELL = "pending_sell"


@dataclass
class GridLevel:
    """A single grid price level."""

    index: int
    price: float
    status: LevelStatus = LevelStatus.EMPTY


@dataclass
class GridOrder:
    """An order generated by the grid strategy."""

    level_index: int
    side: str  # "buy" or "sell"
    price: float
    quantity: float


@dataclass
class GridStrategy:
    """Grid trading bot strategy.

    Places buy and sell orders at predefined price levels within a range.
    Pure computational class with no async, database, or AI dependencies.

    Args:
        symbol: Trading pair symbol (e.g. "BTC/USDT")
        upper_price: Upper bound of the grid range
        lower_price: Lower bound of the grid range
        grid_count: Number of grid intervals (creates grid_count + 1 levels)
        total_investment: Total capital allocated to the grid
        grid_type: Arithmetic or geometric spacing
        auto_stop_on_breakout: Stop when price exits grid range
    """

    symbol: str
    upper_price: float
    lower_price: float
    grid_count: int
    total_investment: float
    grid_type: GridType = GridType.ARITHMETIC
    auto_stop_on_breakout: bool = True

    # State
    levels: list[GridLevel] = field(default_factory=list, init=False, repr=False)
    is_stopped: bool = field(default=False, init=False)
    total_profit: float = field(default=0.0, init=False)
    completed_cycles: int = field(default=0, init=False)
    _initialized: bool = field(default=False, init=False, repr=False)

    def __post_init__(self) -> None:
        if self.upper_price <= self.lower_price:
            raise ValueError("upper_price must be greater than lower_price")
        if self.grid_count < 1:
            raise ValueError("grid_count must be at least 1")
        if self.total_investment <= 0:
            raise ValueError("total_investment must be positive")

    def calculate_grid_levels(self) -> list[float]:
        """Calculate grid price levels.

        Returns:
            List of price levels from lower_price to upper_price.
            Length is grid_count + 1 (fence-post model).
        """
        num_levels = self.grid_count + 1
        prices: list[float] = []

        if self.grid_type == GridType.ARITHMETIC:
            step = (self.upper_price - self.lower_price) / self.grid_count
            for i in range(num_levels):
                prices.append(round(self.lower_price + i * step, 8))
        else:
            ratio = self.upper_price / self.lower_price
            for i in range(num_levels):
                price = self.lower_price * (ratio ** (i / self.grid_count))
                prices.append(round(price, 8))

        return prices

    def generate_initial_orders(self, current_price: float) -> list[GridOrder]:
        """Generate initial grid orders based on current price.

        Buy orders are placed at levels below current price.
        Sell orders are placed at levels above current price.
        Capital per grid cell = total_investment / grid_count.

        Args:
            current_price: Current market price

        Returns:
            List of GridOrder objects to be placed
        """
        if self.is_stopped:
            return []

        prices = self.calculate_grid_levels()
        capital_per_cell = self.total_investment / self.grid_count

        # Initialize levels
        self.levels = [GridLevel(index=i, price=p) for i, p in enumerate(prices)]

        orders: list[GridOrder] = []

        for level in self.levels:
            if level.price < current_price:
                quantity = round(capital_per_cell / level.price, 8)
                level.status = LevelStatus.PENDING_BUY
                orders.append(
                    GridOrder(
                        level_index=level.index,
                        side="buy",
                        price=level.price,
                        quantity=quantity,
                    )
                )
            elif level.price > current_price:
                # Sell orders use quantity based on the level below
                # (what we'd buy at the level below)
                buy_level_price = prices[level.index - 1] if level.index > 0 else level.price
                quantity = round(capital_per_cell / buy_level_price, 8)
                level.status = LevelStatus.PENDING_SELL
                orders.append(
                    GridOrder(
                        level_index=level.index,
                        side="sell",
                        price=level.price,
                        quantity=quantity,
                    )
                )
            # Level at exactly current_price gets no order

        self._initialized = True
        return orders

    def on_order_filled(self, level_index: int, side: str) -> GridOrder | None:
        """Handle an order fill and generate the counter-order.

        When a buy fills at level N, place a sell at level N+1.
        When a sell fills at level N, place a buy at level N-1.

        Args:
            level_index: Index of the level where the order filled
            side: "buy" or "sell"

        Returns:
            Counter GridOrder, or None if at grid boundary or stopped
        """
        if self.is_stopped or not self.levels:
            return None

        if level_index < 0 or level_index >= len(self.levels):
            return None

        prices = [lvl.price for lvl in self.levels]
        capital_per_cell = self.total_investment / self.grid_count

        if side == "buy":
            # Buy filled at level N -> place sell at level N+1
            sell_index = level_index + 1
            if sell_index >= len(self.levels):
                # At top boundary, no counter-order
                self.levels[level_index].status = LevelStatus.EMPTY
                return None

            quantity = round(capital_per_cell / prices[level_index], 8)
            self.levels[level_index].status = LevelStatus.EMPTY
            self.levels[sell_index].status = LevelStatus.PENDING_SELL
            return GridOrder(
                level_index=sell_index,
                side="sell",
                price=prices[sell_index],
                quantity=quantity,
            )

        elif side == "sell":
            # Sell filled at level N -> place buy at level N-1
            buy_index = level_index - 1
            if buy_index < 0:
                # At bottom boundary, no counter-order
                self.levels[level_index].status = LevelStatus.EMPTY
                return None

            # Record profit for this completed cycle
            profit = prices[level_index] - prices[buy_index]
            quantity = round(capital_per_cell / prices[buy_index], 8)
            self.total_profit += profit * quantity
            self.completed_cycles += 1

            self.levels[level_index].status = LevelStatus.EMPTY
            self.levels[buy_index].status = LevelStatus.PENDING_BUY
            return GridOrder(
                level_index=buy_index,
                side="buy",
                price=prices[buy_index],
                quantity=quantity,
            )

        return None

    def check_price_in_range(self, price: float) -> bool:
        """Check if price is within the grid range.

        If auto_stop_on_breakout is True and price is out of range,
        sets is_stopped to True.

        Args:
            price: Current market price

        Returns:
            True if price is within range, False otherwise
        """
        in_range = self.lower_price <= price <= self.upper_price

        if not in_range and self.auto_stop_on_breakout:
            self.is_stopped = True

        return in_range

    def get_profit_per_cycle(self) -> float:
        """Calculate average profit per completed grid cycle.

        Returns:
            Average profit per cycle, or 0.0 if no cycles completed
        """
        if self.completed_cycles == 0:
            return 0.0
        return self.total_profit / self.completed_cycles

    def get_status(self) -> dict:
        """Get current grid strategy status.

        Returns:
            Dictionary with full state for inspection/serialization
        """
        return {
            "symbol": self.symbol,
            "upper_price": self.upper_price,
            "lower_price": self.lower_price,
            "grid_count": self.grid_count,
            "grid_type": self.grid_type.value,
            "total_investment": self.total_investment,
            "auto_stop_on_breakout": self.auto_stop_on_breakout,
            "is_stopped": self.is_stopped,
            "is_initialized": self._initialized,
            "total_profit": round(self.total_profit, 8),
            "completed_cycles": self.completed_cycles,
            "profit_per_cycle": round(self.get_profit_per_cycle(), 8),
            "levels": [
                {
                    "index": lvl.index,
                    "price": lvl.price,
                    "status": lvl.status.value,
                }
                for lvl in self.levels
            ],
        }
