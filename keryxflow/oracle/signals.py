"""Signal generator combining technical analysis and LLM insights."""

from dataclasses import dataclass
from datetime import UTC, datetime
from enum import Enum
from typing import Any

import pandas as pd

from keryxflow.config import get_settings
from keryxflow.core.events import Event, EventBus, EventType, get_event_bus
from keryxflow.core.logging import get_logger
from keryxflow.oracle.brain import (
    ActionRecommendation,
    MarketBias,
    MarketContext,
    OracleBrain,
    get_oracle_brain,
)
from keryxflow.oracle.feeds import NewsAggregator, NewsDigest, get_news_aggregator
from keryxflow.oracle.technical import (
    SignalStrength,
    TechnicalAnalysis,
    TechnicalAnalyzer,
    TrendDirection,
    get_technical_analyzer,
)

logger = get_logger(__name__)


class SignalType(str, Enum):
    """Type of trading signal."""

    LONG = "long"
    SHORT = "short"
    CLOSE_LONG = "close_long"
    CLOSE_SHORT = "close_short"
    NO_ACTION = "no_action"


class SignalSource(str, Enum):
    """Source of signal."""

    TECHNICAL = "technical"
    LLM = "llm"
    HYBRID = "hybrid"


@dataclass
class TradingSignal:
    """A trading signal generated by the Oracle."""

    symbol: str
    signal_type: SignalType
    strength: SignalStrength
    confidence: float  # 0.0 to 1.0
    source: SignalSource
    timestamp: datetime

    # Price targets
    entry_price: float | None = None
    stop_loss: float | None = None
    take_profit: float | None = None
    risk_reward: float | None = None

    # Context
    technical_trend: TrendDirection | None = None
    llm_bias: MarketBias | None = None
    news_sentiment: str | None = None

    # Explanations
    simple_reason: str = ""
    technical_reason: str = ""

    # Component data
    technical_data: dict[str, Any] | None = None
    llm_data: dict[str, Any] | None = None

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "symbol": self.symbol,
            "signal_type": self.signal_type.value,
            "strength": self.strength.value,
            "confidence": self.confidence,
            "source": self.source.value,
            "timestamp": self.timestamp.isoformat(),
            "entry_price": self.entry_price,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "risk_reward": self.risk_reward,
            "technical_trend": self.technical_trend.value if self.technical_trend else None,
            "llm_bias": self.llm_bias.value if self.llm_bias else None,
            "news_sentiment": self.news_sentiment,
            "simple_reason": self.simple_reason,
            "technical_reason": self.technical_reason,
        }

    @property
    def is_actionable(self) -> bool:
        """Check if signal is actionable (not NO_ACTION)."""
        return self.signal_type != SignalType.NO_ACTION

    @property
    def is_entry(self) -> bool:
        """Check if signal is an entry signal."""
        return self.signal_type in (SignalType.LONG, SignalType.SHORT)


class SignalGenerator:
    """
    Generates trading signals by combining technical analysis and LLM insights.

    The generator follows a hybrid approach:
    1. Technical analysis provides the primary signal
    2. LLM analysis validates/vetos based on market context
    3. Combined confidence determines final strength
    """

    def __init__(
        self,
        technical_analyzer: TechnicalAnalyzer | None = None,
        news_aggregator: NewsAggregator | None = None,
        brain: OracleBrain | None = None,
        event_bus: EventBus | None = None,
        publish_events: bool = True,
    ):
        """Initialize the signal generator.

        Args:
            technical_analyzer: Custom technical analyzer (optional)
            news_aggregator: Custom news aggregator (optional)
            brain: Custom LLM brain (optional)
            event_bus: Custom event bus (optional)
            publish_events: Whether to publish events (disable for backtesting)
        """
        self.settings = get_settings()
        self.technical = technical_analyzer or get_technical_analyzer()
        self.news = news_aggregator or get_news_aggregator()
        self.brain = brain or get_oracle_brain()
        self.event_bus = event_bus or get_event_bus()
        self._publish_events = publish_events

        # Signal history for deduplication
        self._last_signals: dict[str, TradingSignal] = {}

    async def generate_signal(
        self,
        symbol: str,
        ohlcv: pd.DataFrame,
        current_price: float | None = None,
        include_news: bool = True,
        include_llm: bool = True,
    ) -> TradingSignal:
        """
        Generate a trading signal for a symbol.

        Args:
            symbol: Trading pair symbol
            ohlcv: OHLCV DataFrame
            current_price: Current price (defaults to last close)
            include_news: Whether to include news analysis
            include_llm: Whether to include LLM analysis

        Returns:
            TradingSignal with recommendation
        """
        if current_price is None:
            current_price = float(ohlcv["close"].iloc[-1])

        # Step 1: Technical Analysis
        try:
            technical = self.technical.analyze(ohlcv, symbol)
        except ValueError as e:
            logger.warning("technical_analysis_failed", symbol=symbol, error=str(e))
            return self._no_action_signal(symbol, f"Technical analysis failed: {e}")

        # Step 2: News Analysis (optional)
        news_digest: NewsDigest | None = None
        if include_news and self.settings.oracle.news_enabled:
            try:
                news_digest = await self.news.fetch_news(symbols=[symbol])
            except Exception as e:
                logger.warning("news_fetch_failed", symbol=symbol, error=str(e))

        # Step 3: LLM Analysis (optional)
        llm_context: MarketContext | None = None
        if include_llm and self.settings.oracle.llm_enabled:
            try:
                llm_context = await self.brain.analyze(symbol, technical, news_digest)
            except Exception as e:
                logger.warning("llm_analysis_failed", symbol=symbol, error=str(e))

        # Step 4: Combine signals
        signal = self._combine_signals(
            symbol=symbol,
            current_price=current_price,
            technical=technical,
            news=news_digest,
            llm=llm_context,
        )

        # Step 5: Check for signal changes
        if self._is_significant_change(symbol, signal):
            if self._publish_events:
                await self.event_bus.publish(
                    Event(type=EventType.SIGNAL_GENERATED, data=signal.to_dict())
                )
            self._last_signals[symbol] = signal

        logger.info(
            "signal_generated",
            symbol=symbol,
            type=signal.signal_type.value,
            strength=signal.strength.value,
            confidence=signal.confidence,
        )

        return signal

    def _combine_signals(
        self,
        symbol: str,
        current_price: float,
        technical: TechnicalAnalysis,
        news: NewsDigest | None,
        llm: MarketContext | None,
    ) -> TradingSignal:
        """Combine technical, news, and LLM signals."""
        # Start with technical signal
        base_signal = self._technical_to_signal(technical)
        base_confidence = technical.confidence

        # Determine source
        source = SignalSource.TECHNICAL

        # Adjust with LLM if available
        if llm:
            source = SignalSource.HYBRID
            adjusted_signal, llm_confidence = self._adjust_with_llm(base_signal, llm)

            # Weighted average of confidences
            base_confidence = (base_confidence * 0.6) + (llm_confidence * 0.4)
            base_signal = adjusted_signal

        # Calculate price targets
        entry, stop_loss, take_profit = self._calculate_targets(
            current_price, base_signal, technical
        )

        # Calculate risk/reward if targets are set
        risk_reward = None
        if stop_loss and take_profit:
            risk = abs(current_price - stop_loss)
            reward = abs(take_profit - current_price)
            risk_reward = reward / risk if risk > 0 else 0

        # Determine final strength
        strength = self._confidence_to_strength(base_confidence)

        # Generate explanations
        simple_reason = self._generate_simple_reason(base_signal, technical, llm)
        technical_reason = self._generate_technical_reason(base_signal, technical, llm)

        return TradingSignal(
            symbol=symbol,
            signal_type=base_signal,
            strength=strength,
            confidence=base_confidence,
            source=source,
            timestamp=datetime.now(UTC),
            entry_price=entry,
            stop_loss=stop_loss,
            take_profit=take_profit,
            risk_reward=risk_reward,
            technical_trend=technical.overall_trend,
            llm_bias=llm.bias if llm else None,
            news_sentiment=news.overall_sentiment.value if news else None,
            simple_reason=simple_reason,
            technical_reason=technical_reason,
            technical_data=technical.to_dict(),
            llm_data=llm.to_dict() if llm else None,
        )

    def _technical_to_signal(self, technical: TechnicalAnalysis) -> SignalType:
        """Convert technical analysis to signal type."""
        strong_signals = (SignalStrength.STRONG, SignalStrength.MODERATE)

        if technical.overall_trend == TrendDirection.BULLISH and technical.overall_strength in strong_signals:
            return SignalType.LONG
        elif technical.overall_trend == TrendDirection.BEARISH and technical.overall_strength in strong_signals:
            return SignalType.SHORT

        return SignalType.NO_ACTION

    def _adjust_with_llm(
        self, base_signal: SignalType, llm: MarketContext
    ) -> tuple[SignalType, float]:
        """Adjust signal based on LLM analysis."""
        # LLM can veto signals if context is unfavorable
        if base_signal == SignalType.LONG:
            if llm.bias in (MarketBias.BEARISH, MarketBias.STRONGLY_BEARISH):
                # LLM disagrees - reduce to no action
                return SignalType.NO_ACTION, llm.confidence * 0.5
            elif llm.recommendation == ActionRecommendation.WAIT:
                # LLM suggests waiting
                return SignalType.NO_ACTION, llm.confidence * 0.7

        elif base_signal == SignalType.SHORT:
            if llm.bias in (MarketBias.BULLISH, MarketBias.STRONGLY_BULLISH):
                # LLM disagrees - reduce to no action
                return SignalType.NO_ACTION, llm.confidence * 0.5
            elif llm.recommendation == ActionRecommendation.WAIT:
                # LLM suggests waiting
                return SignalType.NO_ACTION, llm.confidence * 0.7

        elif base_signal == SignalType.NO_ACTION:
            # LLM can upgrade weak signals
            if llm.recommendation == ActionRecommendation.STRONG_BUY:
                return SignalType.LONG, llm.confidence * 0.8
            elif llm.recommendation == ActionRecommendation.STRONG_SELL:
                return SignalType.SHORT, llm.confidence * 0.8

        return base_signal, llm.confidence

    def _calculate_targets(
        self,
        current_price: float,
        signal: SignalType,
        technical: TechnicalAnalysis,
    ) -> tuple[float | None, float | None, float | None]:
        """Calculate entry, stop loss, and take profit targets."""
        if signal == SignalType.NO_ACTION:
            return None, None, None

        entry = current_price

        # Get ATR for volatility-based targets
        atr_result = technical.indicators.get("atr")
        atr_pct = 0.02  # Default 2%

        if atr_result and isinstance(atr_result.value, dict):
            atr_pct = atr_result.value.get("atr_pct", 0.02)

        # Calculate stops and targets
        if signal == SignalType.LONG:
            stop_loss = entry * (1 - atr_pct * 1.5)  # 1.5x ATR stop
            take_profit = entry * (1 + atr_pct * 3)  # 3x ATR target (2:1 R:R)
        elif signal == SignalType.SHORT:
            stop_loss = entry * (1 + atr_pct * 1.5)
            take_profit = entry * (1 - atr_pct * 3)
        else:
            return entry, None, None

        return entry, stop_loss, take_profit

    def _confidence_to_strength(self, confidence: float) -> SignalStrength:
        """Convert confidence to signal strength."""
        if confidence >= 0.7:
            return SignalStrength.STRONG
        elif confidence >= 0.5:
            return SignalStrength.MODERATE
        elif confidence >= 0.3:
            return SignalStrength.WEAK
        else:
            return SignalStrength.NONE

    def _generate_simple_reason(
        self,
        signal: SignalType,
        technical: TechnicalAnalysis,
        llm: MarketContext | None,
    ) -> str:
        """Generate a beginner-friendly explanation."""
        if signal == SignalType.NO_ACTION:
            return "No clear opportunity right now. Better to wait."

        action = "buying" if signal == SignalType.LONG else "selling"

        if llm and llm.simple_explanation:
            return f"Signal suggests {action}. {llm.simple_explanation}"

        return f"Technical indicators suggest {action}. {technical.simple_summary}"

    def _generate_technical_reason(
        self,
        signal: SignalType,
        technical: TechnicalAnalysis,
        llm: MarketContext | None,
    ) -> str:
        """Generate a technical explanation."""
        parts = [f"Signal: {signal.value.upper()}"]
        parts.append(technical.technical_summary)

        if llm:
            parts.append(f"LLM Bias: {llm.bias.value} ({llm.confidence:.0%})")
            if llm.reasoning:
                parts.append(llm.reasoning)

        return " | ".join(parts)

    def _no_action_signal(self, symbol: str, reason: str) -> TradingSignal:
        """Create a no-action signal."""
        return TradingSignal(
            symbol=symbol,
            signal_type=SignalType.NO_ACTION,
            strength=SignalStrength.NONE,
            confidence=0.0,
            source=SignalSource.TECHNICAL,
            timestamp=datetime.now(UTC),
            simple_reason=reason,
            technical_reason=reason,
        )

    def _is_significant_change(self, symbol: str, new_signal: TradingSignal) -> bool:
        """Check if signal represents a significant change."""
        last = self._last_signals.get(symbol)
        if last is None:
            return True

        # Check if signal type changed
        if new_signal.signal_type != last.signal_type:
            return True

        # Check if confidence changed significantly
        if abs(new_signal.confidence - last.confidence) > 0.2:
            return True

        # Check if strength changed
        if new_signal.strength != last.strength:
            return True

        return False

    def format_signal(self, signal: TradingSignal, simple: bool = True) -> str:
        """Format a signal for display."""
        if simple:
            emoji_map = {
                SignalType.LONG: "ðŸ“ˆ",
                SignalType.SHORT: "ðŸ“‰",
                SignalType.CLOSE_LONG: "ðŸ”’",
                SignalType.CLOSE_SHORT: "ðŸ”’",
                SignalType.NO_ACTION: "â³",
            }
            emoji = emoji_map.get(signal.signal_type, "â“")

            strength_bar = {
                SignalStrength.STRONG: "â–ˆâ–ˆâ–ˆâ–ˆ",
                SignalStrength.MODERATE: "â–ˆâ–ˆâ–ˆâ–‘",
                SignalStrength.WEAK: "â–ˆâ–ˆâ–‘â–‘",
                SignalStrength.NONE: "â–‘â–‘â–‘â–‘",
            }
            bar = strength_bar.get(signal.strength, "â–‘â–‘â–‘â–‘")

            lines = [
                f"{emoji} Signal: {signal.signal_type.value.upper()} @ {signal.symbol}",
                f"   Strength: {bar} ({signal.confidence:.0%})",
            ]

            if signal.is_entry and signal.entry_price:
                lines.append(f"   Entry: ${signal.entry_price:,.2f}")
                if signal.stop_loss:
                    lines.append(f"   Stop:  ${signal.stop_loss:,.2f}")
                if signal.take_profit:
                    lines.append(f"   Target: ${signal.take_profit:,.2f}")
                if signal.risk_reward:
                    lines.append(f"   R:R: {signal.risk_reward:.1f}:1")

            lines.append(f"   {signal.simple_reason}")

            return "\n".join(lines)
        else:
            return signal.technical_reason


# Global instance
_generator: SignalGenerator | None = None


def get_signal_generator() -> SignalGenerator:
    """Get the global signal generator instance."""
    global _generator
    if _generator is None:
        _generator = SignalGenerator()
    return _generator
